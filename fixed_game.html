<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Pizza Quest - Fixed Version</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c3e50;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #000;
            margin: 20px 0;
            display: block;
        }
        .instructions {
            max-width: 800px;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        h1 {
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Pixel Pizza Quest - Fixed Version</h1>
    
    <div class="instructions">
        <h2>Controls:</h2>
        <ul>
            <li>Left/Right Arrow Keys: Move left/right</li>
            <li>Up Arrow Key: Jump (can combine with left/right for diagonal jumps)</li>
            <li>Spacebar: Shoot projectiles</li>
        </ul>
        <p>Note: Open your browser's developer console (F12 or Cmd+Option+I) to see debug messages</p>
        <button id="jumpButton" style="padding: 10px 20px; font-size: 18px; margin-top: 10px;">JUMP!</button>
    </div>
    
    <!-- Empty div for game canvas -->
    <div id="game"></div>
    
    <!-- Phaser CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    
    <script>
        // Wait for document to be fully loaded
        window.onload = function() {
            // Check if Phaser is loaded
            if (typeof Phaser === 'undefined') {
                alert('Could not load Phaser library. Please check your internet connection.');
                return;
            }
            
            // Game configuration
            const config = {
                type: Phaser.AUTO,
                width: 800,
                height: 400,
                parent: 'game',
                backgroundColor: '#87CEEB',
                physics: {
                    default: 'arcade',
                    arcade: {
                        gravity: { y: 300 },
                        debug: true // Set to true to see physics bodies
                    }
                },
                scene: {
                    preload: preload,
                    create: create,
                    update: update
                }
            };
            
            // Global variables
            let player;
            let enemies;
            let boss;
            let platforms;
            let cursors;
            let gameOver = false;
            let health = 5;
            let healthText;
            let currentScreen = 1;
            let totalScreens = 5;
            let jumpKey;
            let invincible = false;
            let invincibleTimer = null;
            let projectiles;
            let shootKey;
            let lastShootTime = 0;
            let currentScreenText;
            let bossHealth = 10;
            let bossHealthText;
            let bossAttackTimer = null;
            let gameWon = false;
            let winText;
            
            // Initialize the game
            try {
                const game = new Phaser.Game(config);
                console.log('Game initialized successfully');
            } catch (error) {
                console.error('Error initializing game:', error);
                alert('Error starting game: ' + error.message);
            }
            
            // Preload assets
            function preload() {
                console.log('Preload started');
                
                // Create graphics for placeholder textures
                createPlaceholderTextures(this);
                
                console.log('Preload completed');
            }
            
            // Create game elements
            function create() {
                console.log('Create started');
                
                // Add platforms
                platforms = this.physics.add.staticGroup();
                
                // Main ground platform
                platforms.create(400, 380, 'platform').setScale(2).refreshBody();
                
                // Some floating platforms
                platforms.create(600, 250, 'platform');
                platforms.create(200, 200, 'platform');
                platforms.create(750, 150, 'platform');
                
                // Add player
                player = this.physics.add.sprite(100, 300, 'player');
                player.setBounce(0.2);
                player.setCollideWorldBounds(true);
                
                // Create projectiles group
                projectiles = this.physics.add.group({
                    allowGravity: false,
                    bounceX: 0,
                    bounceY: 0
                });
                
                // Set up keyboard input
                cursors = this.input.keyboard.createCursorKeys();
                
                // Add jump key for more reliable jumping
                jumpKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP);
                try {
                    jumpKey.on('down', function() {
                        if (player && player.body) {
                            const touchingDown = player.body.touching ? player.body.touching.down : false;
                            const blockedDown = player.body.blocked ? player.body.blocked.down : false;
                            
                            if (touchingDown || blockedDown) {
                                player.setVelocityY(-330);
                                console.log('Jump executed!');
                            }
                        }
                    });
                } catch (e) {
                    console.error('Error setting up jump key:', e);
                }
                
                // Add shoot key for projectiles
                shootKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                try {
                    shootKey.on('down', function() {
                        shootProjectile();
                    });
                } catch (e) {
                    console.error('Error setting up shoot key:', e);
                }
                
                // Add jump button click handler
                document.getElementById('jumpButton').addEventListener('click', function() {
                    try {
                        if (player && player.body) {
                            const touchingDown = player.body.touching ? player.body.touching.down : false;
                            const blockedDown = player.body.blocked ? player.body.blocked.down : false;
                            
                            if (touchingDown || blockedDown) {
                                player.setVelocityY(-330);
                                console.log('Jump executed from button!');
                            }
                        }
                    } catch (e) {
                        console.error('Error in jump button:', e);
                    }
                });
                
                // Set up collisions
                this.physics.add.collider(player, platforms);
                
                // Create enemies
                enemies = this.physics.add.group();
                
                // Spawn enemies for the current screen
                spawnEnemies(this);
                
                // Set up enemy collisions
                this.physics.add.collider(enemies, platforms);
                this.physics.add.collider(projectiles, platforms, hitPlatform, null, this);
                this.physics.add.collider(projectiles, enemies, hitEnemyWithProjectile, null, this);
                
                // Final boss
                boss = this.physics.add.sprite(700, 200, 'boss');
                boss.setBounce(0.2);
                boss.setCollideWorldBounds(true);
                boss.setVisible(false);
                boss.setActive(false);
                
                // Initialize boss health display (hidden until final screen)
                bossHealthText = this.add.text(400, 50, 'Boss: ' + bossHealth, { 
                    fontSize: '32px', 
                    fill: '#ff0000',
                    backgroundColor: '#000000',
                    padding: { x: 10, y: 5 }
                }).setOrigin(0.5, 0);
                bossHealthText.setVisible(false);
                
                // Win text (hidden initially)
                winText = this.add.text(400, 200, 'YOU WIN!', { 
                    fontSize: '64px', 
                    fill: '#ffff00',
                    backgroundColor: '#000000',
                    padding: { x: 20, y: 10 }
                }).setOrigin(0.5, 0.5);
                winText.setVisible(false);
                
                this.physics.add.collider(boss, platforms);
                this.physics.add.collider(projectiles, boss, hitBossWithProjectile, null, this);
                
                // Add health display
                healthText = this.add.text(16, 16, 'Health: ' + health, { fontSize: '32px', fill: '#fff' });
                
                // Add current screen display
                currentScreenText = this.add.text(400, 16, 'Screen: ' + currentScreen + '/' + totalScreens, {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5, 0);
                
                // Collisions between player and enemies
                this.physics.add.overlap(player, enemies, hitEnemy, null, this);
                this.physics.add.overlap(player, boss, hitBoss, null, this);
                
                // Add a visible message to the page
                const loadingEl = document.getElementById('loading-message');
                if (!loadingEl) {
                    const newLoadingEl = document.createElement('div');
                    newLoadingEl.id = 'loading-message';
                    newLoadingEl.style.color = 'white';
                    newLoadingEl.style.fontWeight = 'bold';
                    newLoadingEl.style.padding = '10px';
                    newLoadingEl.style.backgroundColor = 'rgba(0,0,0,0.5)';
                    newLoadingEl.style.margin = '10px';
                    newLoadingEl.textContent = 'Game loaded successfully! Use arrow keys to move, spacebar to shoot.';
                    document.body.appendChild(newLoadingEl);
                } else {
                    loadingEl.style.display = 'block';
                    loadingEl.textContent = 'Game loaded successfully! Use arrow keys to move, spacebar to shoot.';
                }
                
                console.log('Create completed');
            }
            
            // Spawn enemies based on current screen
            function spawnEnemies(scene) {
                console.log('Spawning enemies for screen', currentScreen);
                
                // Clear existing enemies
                enemies.clear(true, true);
                
                if (currentScreen === totalScreens) {
                    // Final screen has boss instead of enemies
                    initializeBossFight(scene);
                    return;
                }
                
                // Number of enemies increases with each screen
                const enemyCount = 2 + currentScreen;
                
                for (let i = 0; i < enemyCount; i++) {
                    // Alternate between red and blue rats
                    const enemyType = i % 2 === 0 ? 'rat_red' : 'rat_blue';
                    
                    // Position enemies across the screen
                    const x = 200 + (i * 120) % 500;
                    const y = 100 + (i % 3) * 80;
                    
                    const enemy = enemies.create(x, y, enemyType);
                    enemy.setBounce(0.2);
                    enemy.setCollideWorldBounds(true);
                    
                    // Set alternating directions
                    enemy.setVelocityX(i % 2 === 0 ? -50 : 50);
                    
                    console.log(`Created ${enemyType} at ${x},${y}`);
                }
            }
            
            // Initialize boss fight
            function initializeBossFight(scene) {
                console.log('Initializing boss fight!');
                
                // Reset boss health for new fight
                bossHealth = 10;
                
                // Activate boss
                boss.setVisible(true);
                boss.setActive(true);
                boss.x = 700;
                boss.y = 200;
                boss.body.allowGravity = true;
                boss.setVelocityX(-60);
                
                // Show boss health
                bossHealthText.setText('Boss: ' + bossHealth);
                bossHealthText.setVisible(true);
                
                // Start boss attack pattern
                if (bossAttackTimer) {
                    bossAttackTimer.remove();
                }
                
                bossAttackTimer = scene.time.addEvent({
                    delay: 2000,
                    callback: bossShooting,
                    callbackScope: scene,
                    loop: true
                });
            }
            
            // Boss shooting function
            function bossShooting() {
                if (!boss.active || !boss.visible || gameOver || gameWon) {
                    return;
                }
                
                console.log('Boss is attacking!');
                
                // Create a boss projectile
                const bossProjectile = projectiles.create(boss.x, boss.y, 'boss_projectile');
                bossProjectile.setData('type', 'boss'); // Mark as boss projectile
                
                // Calculate direction toward player
                const angle = Phaser.Math.Angle.Between(boss.x, boss.y, player.x, player.y);
                
                // Set projectile velocity based on angle
                const projectileSpeed = 200;
                bossProjectile.setVelocityX(Math.cos(angle) * projectileSpeed);
                bossProjectile.setVelocityY(Math.sin(angle) * projectileSpeed);
                
                // Make boss flash when shooting
                boss.setTint(0xffff00);
                boss.scene.time.delayedCall(100, function() {
                    boss.clearTint();
                });
                
                // Boss jumps sometimes
                if (boss.body) {
                    const touchingDown = boss.body.touching ? boss.body.touching.down : false;
                    if (touchingDown && Math.random() > 0.5) {
                        boss.setVelocityY(-300);
                    }
                }
                
                // Boss changes direction occasionally
                if (Math.random() > 0.7) {
                    boss.setVelocityX(-boss.body.velocity.x);
                }
            }
            
            // Update game state
            function update(time) {
                if (gameOver) {
                    // If game over, stop all player movement
                    player.setVelocityX(0);
                    return;
                }
                
                if (gameWon) {
                    return;
                }
                
                // Debug ground detection
                if (player.body) {
                    const touchingDown = player.body.touching ? player.body.touching.down : false;
                    const blockedDown = player.body.blocked ? player.body.blocked.down : false;
                    
                    if (touchingDown || blockedDown) {
                        if (!player.wasOnGround) {
                            console.log('Player is now on ground!');
                            player.wasOnGround = true;
                        }
                    } else {
                        if (player.wasOnGround) {
                            console.log('Player is now in air!');
                            player.wasOnGround = false;
                        }
                    }
                }
                
                // Player movement - allow movement regardless of damage state
                if (cursors.left.isDown) {
                    player.setVelocityX(-160);
                    player.flipX = true;
                } else if (cursors.right.isDown) {
                    player.setVelocityX(160);
                    player.flipX = false;
                } else {
                    player.setVelocityX(0);
                }
                
                // Jump with up arrow
                if (cursors.up.isDown && player.body) {
                    const touchingDown = player.body.touching ? player.body.touching.down : false;
                    const blockedDown = player.body.blocked ? player.body.blocked.down : false;
                    
                    if (touchingDown || blockedDown) {
                        player.setVelocityY(-330);
                    }
                }
                
                // Manual shooting check in update loop
                if (Phaser.Input.Keyboard.JustDown(shootKey)) {
                    if (time - lastShootTime > 500) { // Cooldown of 500ms
                        shootProjectile();
                        lastShootTime = time;
                    }
                }
                
                // Update enemies
                enemies.getChildren().forEach(enemy => {
                    if (enemy.body) {
                        const touchingRight = enemy.body.touching ? enemy.body.touching.right : false;
                        const blockedRight = enemy.body.blocked ? enemy.body.blocked.right : false;
                        const touchingLeft = enemy.body.touching ? enemy.body.touching.left : false;
                        const blockedLeft = enemy.body.blocked ? enemy.body.blocked.left : false;
                        
                        if (touchingRight || blockedRight) {
                            enemy.setVelocityX(-50);
                        } else if (touchingLeft || blockedLeft) {
                            enemy.setVelocityX(50);
                        }
                    }
                });
                
                // Update boss direction based on walls
                if (boss && boss.active && boss.visible) {
                    try {
                        if (boss.body) {
                            const touchingRight = boss.body.touching ? boss.body.touching.right : false;
                            const blockedRight = boss.body.blocked ? boss.body.blocked.right : false;
                            const touchingLeft = boss.body.touching ? boss.body.touching.left : false;
                            const blockedLeft = boss.body.blocked ? boss.body.blocked.left : false;
                            
                            if (touchingRight || blockedRight) {
                                boss.setVelocityX(-60);
                            } else if (touchingLeft || blockedLeft) {
                                boss.setVelocityX(60);
                            }
                            
                            // Make sure boss doesn't get stuck
                            if (boss.x < 10) {
                                boss.x = 10;
                                boss.setVelocityX(60);
                            } else if (boss.x > 790) {
                                boss.x = 790;
                                boss.setVelocityX(-60);
                            }
                            
                            // Make sure boss stays on screen
                            if (boss.y > 380) {
                                boss.y = 380;
                                boss.setVelocityY(-100);
                            }
                        }
                    } catch (e) {
                        console.error('Error updating boss:', e);
                    }
                }
                
                // Clean up projectiles that have gone offscreen
                projectiles.getChildren().forEach(projectile => {
                    if (projectile.x < 0 || projectile.x > 800 || 
                        projectile.y < 0 || projectile.y > 400) {
                        projectile.destroy();
                    }
                });
                
                // Player hit by boss projectiles
                projectiles.getChildren().forEach(projectile => {
                    if (projectile.getData('type') === 'boss') {
                        if (Phaser.Geom.Rectangle.Overlaps(
                            new Phaser.Geom.Rectangle(player.x - 16, player.y - 24, 32, 48),
                            new Phaser.Geom.Rectangle(projectile.x - 8, projectile.y - 8, 16, 16)
                        )) {
                            projectile.destroy();
                            hitByBossProjectile();
                        }
                    }
                });
                
                // Screen transition
                if (player.x > 780 && currentScreen < totalScreens) {
                    currentScreen++;
                    player.x = 20;
                    
                    // Update screen number display
                    currentScreenText.setText('Screen: ' + currentScreen + '/' + totalScreens);
                    
                    // Spawn new enemies for this screen
                    spawnEnemies(this);
                }
            }
            
            // Hit by boss projectile
            function hitByBossProjectile() {
                if (!invincible) {
                    takeDamage();
                    
                    // Make player temporarily invincible
                    invincible = true;
                    player.alpha = 0.5; // Visual feedback
                    
                    // Reset invincibility after 1 second
                    if (invincibleTimer) {
                        invincibleTimer.remove();
                    }
                    
                    invincibleTimer = player.scene.time.delayedCall(1000, function() {
                        invincible = false;
                        player.alpha = 1; // Restore visibility
                        console.log('Player can take damage again');
                    });
                }
            }
            
            // Shoot projectile function
            function shootProjectile() {
                if (!player || !player.scene || gameOver) return;
                
                console.log('Shooting projectile!');
                const projectile = projectiles.create(
                    player.x + (player.flipX ? -20 : 20), 
                    player.y, 
                    'projectile'
                );
                
                // Set projectile velocity based on player direction
                const projectileSpeed = 400;
                projectile.setVelocityX(player.flipX ? -projectileSpeed : projectileSpeed);
                
                // Add a small random vertical velocity for variation
                projectile.setVelocityY((Math.random() - 0.5) * 50);
            }
            
            // Handle projectile hitting platform
            function hitPlatform(projectile) {
                projectile.destroy();
            }
            
            // Handle projectile hitting enemy
            function hitEnemyWithProjectile(projectile, enemy) {
                projectile.destroy();
                enemy.destroy();
                console.log('Enemy destroyed by projectile!');
                
                // If all enemies are gone, spawn a new one to keep the game challenging
                if (enemies.countActive() === 0 && currentScreen < totalScreens) {
                    // Don't spawn new enemies if we're on the final screen
                    const x = Phaser.Math.Between(100, 700);
                    const y = 100;
                    const enemyType = Math.random() > 0.5 ? 'rat_red' : 'rat_blue';
                    
                    const enemy = enemies.create(x, y, enemyType);
                    enemy.setBounce(0.2);
                    enemy.setCollideWorldBounds(true);
                    enemy.setVelocityX(Math.random() > 0.5 ? -50 : 50);
                    
                    console.log(`Created replacement ${enemyType} at ${x},${y}`);
                }
            }
            
            // Handle projectile hitting boss
            function hitBossWithProjectile(projectile, boss) {
                // Only player projectiles damage the boss
                if (projectile.getData('type') !== 'boss') {
                    projectile.destroy();
                    
                    // Decrease boss health
                    bossHealth--;
                    bossHealthText.setText('Boss: ' + bossHealth);
                    console.log('Boss hit by projectile! Health: ' + bossHealth);
                    
                    // Visual feedback
                    boss.setTint(0xff0000); // Flash red
                    
                    // Reset tint after 100ms
                    boss.scene.time.delayedCall(100, function() {
                        boss.clearTint();
                    });
                    
                    // Check if boss is defeated
                    if (bossHealth <= 0) {
                        bossDeath();
                    } else {
                        // Boss gets faster when damaged
                        const currentVelX = boss.body.velocity.x;
                        const direction = currentVelX > 0 ? 1 : -1;
                        const speed = Math.min(200, Math.abs(currentVelX) + 10);
                        boss.setVelocityX(direction * speed);
                        
                        // Boss jumps when hit
                        if (boss.body) {
                            const touchingDown = boss.body.touching ? boss.body.touching.down : false;
                            if (touchingDown) {
                                boss.setVelocityY(-300);
                            }
                        }
                    }
                }
            }
            
            // Boss death function
            function bossDeath() {
                boss.setTint(0xff0000);
                boss.setVelocityX(0);
                boss.setVelocityY(0);
                
                // Stop boss attacks
                if (bossAttackTimer) {
                    bossAttackTimer.remove();
                }
                
                // Clear any remaining projectiles
                projectiles.clear(true, true);
                
                // Show win text
                gameWon = true;
                winText.setVisible(true);
                
                // Flash the boss
                let flashCount = 0;
                const flashInterval = setInterval(() => {
                    boss.setVisible(!boss.visible);
                    flashCount++;
                    
                    if (flashCount > 10) {
                        clearInterval(flashInterval);
                        boss.destroy();
                    }
                }, 100);
                
                console.log('Boss defeated! You win!');
            }
            
            // Handle collision with enemies
            function hitEnemy(player, enemy) {
                if (!invincible) {
                    takeDamage();
                    
                    // Make player temporarily invincible
                    invincible = true;
                    player.alpha = 0.5; // Visual feedback
                    
                    // Reset invincibility after 1 second
                    if (invincibleTimer) {
                        invincibleTimer.remove();
                    }
                    
                    invincibleTimer = player.scene.time.delayedCall(1000, function() {
                        invincible = false;
                        player.alpha = 1; // Restore visibility
                        console.log('Player can take damage again');
                    });
                }
            }
            
            // Handle collision with boss
            function hitBoss(player, boss) {
                if (!invincible) {
                    takeDamage();
                    
                    // Make player temporarily invincible
                    invincible = true;
                    player.alpha = 0.5; // Visual feedback
                    
                    // Reset invincibility after 1 second
                    if (invincibleTimer) {
                        invincibleTimer.remove();
                    }
                    
                    invincibleTimer = player.scene.time.delayedCall(1000, function() {
                        invincible = false;
                        player.alpha = 1; // Restore visibility
                        console.log('Player can take damage again');
                    });
                }
            }
            
            // Take damage function
            function takeDamage() {
                health--;
                healthText.setText('Health: ' + health);
                console.log('Player took damage! Health: ' + health);
                
                if (health <= 0) {
                    gameOver = true;
                    player.setTint(0xff0000);
                    console.log('Game over!');
                }
            }
            
            // Create placeholder textures function
            function createPlaceholderTextures(scene) {
                try {
                    console.log('Creating placeholder textures');
                    
                    // Platform texture (brown rectangle)
                    const platformGraphics = scene.make.graphics({x: 0, y: 0, add: false});
                    platformGraphics.fillStyle(0x8B4513, 1); // Brown color
                    platformGraphics.fillRect(0, 0, 200, 32);
                    platformGraphics.generateTexture('platform', 200, 32);
                    
                    // Player texture (yellow rectangle with eyes)
                    const playerGraphics = scene.make.graphics({x: 0, y: 0, add: false});
                    
                    // Normal state
                    playerGraphics.fillStyle(0xFFD700, 1); // Gold color
                    playerGraphics.fillRect(0, 0, 32, 48);
                    playerGraphics.fillStyle(0x000000, 1); // Black for eyes
                    playerGraphics.fillRect(8, 12, 4, 4);
                    playerGraphics.fillRect(20, 12, 4, 4);
                    playerGraphics.strokeRect(0, 0, 32, 48);
                    playerGraphics.generateTexture('player', 32, 48);
                    
                    // Attack state
                    playerGraphics.clear();
                    playerGraphics.fillStyle(0xFFD700, 1); // Gold color
                    playerGraphics.fillRect(0, 0, 32, 48);
                    playerGraphics.fillStyle(0x000000, 1); // Black for eyes
                    playerGraphics.fillRect(8, 12, 4, 4);
                    playerGraphics.fillRect(20, 12, 4, 4);
                    playerGraphics.fillStyle(0xFF0000, 1); // Red for attack
                    playerGraphics.fillRect(32, 20, 16, 8); // Attack area
                    playerGraphics.strokeRect(0, 0, 32, 48);
                    playerGraphics.generateTexture('player_attack', 48, 48);
                    
                    // Projectile texture (green circle)
                    const projectileGraphics = scene.make.graphics({x: 0, y: 0, add: false});
                    projectileGraphics.fillStyle(0x00FF00, 1); // Green color
                    projectileGraphics.fillCircle(8, 8, 8);
                    projectileGraphics.generateTexture('projectile', 16, 16);
                    
                    // Boss projectile texture (red circle)
                    const bossProjectileGraphics = scene.make.graphics({x: 0, y: 0, add: false});
                    bossProjectileGraphics.fillStyle(0xFF0000, 1); // Red color
                    bossProjectileGraphics.fillCircle(8, 8, 8);
                    bossProjectileGraphics.generateTexture('boss_projectile', 16, 16);
                    
                    // Red rat
                    const redRatGraphics = scene.make.graphics({x: 0, y: 0, add: false});
                    redRatGraphics.fillStyle(0xFF0000, 1);
                    redRatGraphics.fillCircle(16, 16, 16);
                    redRatGraphics.generateTexture('rat_red', 32, 32);
                    
                    // Blue rat
                    const blueRatGraphics = scene.make.graphics({x: 0, y: 0, add: false});
                    blueRatGraphics.fillStyle(0x0000FF, 1);
                    blueRatGraphics.fillCircle(16, 16, 16);
                    blueRatGraphics.generateTexture('rat_blue', 32, 32);
                    
                    // Boss
                    const bossGraphics = scene.make.graphics({x: 0, y: 0, add: false});
                    bossGraphics.fillStyle(0x800080, 1); // Purple
                    bossGraphics.fillRect(0, 0, 64, 64);
                    bossGraphics.fillStyle(0xFFFF00, 1); // Yellow eyes
                    bossGraphics.fillRect(10, 10, 10, 10);
                    bossGraphics.fillRect(44, 10, 10, 10);
                    bossGraphics.generateTexture('boss', 64, 64);
                    
                    console.log('All textures created successfully');
                } catch (error) {
                    console.error('Error creating textures:', error);
                }
            }
        };
    </script>
</body>
</html> 
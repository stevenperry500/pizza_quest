<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Pizza Quest - Safari Compatible</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #2c3e50;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
        }
        #gameContainer {
            margin: 0 auto;
            border: 4px solid white;
            width: 800px;
            height: 400px;
            background-color: black;
        }
        #diagnostics {
            margin-top: 20px;
            padding: 10px;
            text-align: left;
            border: 1px solid #666;
            background-color: rgba(0,0,0,0.3);
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            font-family: monospace;
            height: 150px;
            overflow-y: auto;
            font-size: 12px;
        }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .info { color: #2196F3; }
        #rendererInfo {
            margin-top: 10px;
            font-weight: bold;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <h1>Pixel Pizza Quest</h1>
    <p>Safari-compatible version</p>
    
    <div id="gameContainer"></div>
    <div id="rendererInfo">Initializing game...</div>
    <div id="diagnostics"></div>
    
    <!-- Load Phaser from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    
    <script>
        // Custom logger
        const gameLog = {
            div: document.getElementById('diagnostics'),
            log: function(message, type = 'info') {
                console.log(message);
                const line = document.createElement('div');
                line.className = type;
                line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                this.div.appendChild(line);
                this.div.scrollTop = this.div.scrollHeight;
            },
            success: function(message) {
                this.log(message, 'success');
            },
            error: function(message) {
                this.log(message, 'error');
            }
        };
        
        // Display browser information
        gameLog.log(`Browser: ${navigator.userAgent}`);
        gameLog.log(`Platform: ${navigator.platform}`);
        
        // Create placeholder textures
        function createPlaceholderTextures(scene) {
            // Create player texture
            const playerGraphics = scene.make.graphics({x: 0, y: 0, add: false});
            playerGraphics.fillStyle(0xFFD700); // Gold
            playerGraphics.fillRect(0, 0, 30, 45);
            playerGraphics.generateTexture('player', 30, 45);
            
            // Create platform texture
            const platformGraphics = scene.make.graphics({x: 0, y: 0, add: false});
            platformGraphics.fillStyle(0x8B4513); // Brown
            platformGraphics.fillRect(0, 0, 800, 20);
            platformGraphics.generateTexture('platform', 800, 20);
            
            // Create small platform texture
            const smallPlatformGraphics = scene.make.graphics({x: 0, y: 0, add: false});
            smallPlatformGraphics.fillStyle(0x8B4513); // Brown
            smallPlatformGraphics.fillRect(0, 0, 100, 20);
            smallPlatformGraphics.generateTexture('smallPlatform', 100, 20);
            
            // Create red enemy texture
            const redEnemyGraphics = scene.make.graphics({x: 0, y: 0, add: false});
            redEnemyGraphics.fillStyle(0xFF0000); // Red
            redEnemyGraphics.fillCircle(15, 15, 15);
            redEnemyGraphics.generateTexture('redEnemy', 30, 30);
            
            // Create blue enemy texture
            const blueEnemyGraphics = scene.make.graphics({x: 0, y: 0, add: false});
            blueEnemyGraphics.fillStyle(0x0000FF); // Blue
            blueEnemyGraphics.fillCircle(15, 15, 15);
            blueEnemyGraphics.generateTexture('blueEnemy', 30, 30);
            
            // Create boss texture
            const bossGraphics = scene.make.graphics({x: 0, y: 0, add: false});
            bossGraphics.fillStyle(0x800080); // Purple
            bossGraphics.fillCircle(30, 30, 30);
            bossGraphics.generateTexture('boss', 60, 60);
            
            // Create projectile texture
            const projectileGraphics = scene.make.graphics({x: 0, y: 0, add: false});
            projectileGraphics.fillStyle(0xFFFACD); // LemonChiffon
            projectileGraphics.fillCircle(5, 5, 5);
            projectileGraphics.generateTexture('projectile', 10, 10);
            
            gameLog.success("Created placeholder textures");
        }
        
        // Main game scene
        class MainScene extends Phaser.Scene {
            constructor() {
                super('MainScene');
                this.health = 5;
                this.screen = 1;
                this.totalScreens = 5;
                this.enemiesKilled = 0;
            }
            
            preload() {
                gameLog.log("Preloading game assets...");
                
                // If using external assets, you'd load them here
                // For now, we'll create all assets dynamically in the create function
            }
            
            create() {
                gameLog.log("Creating game scene...");
                
                // Create dynamic textures
                createPlaceholderTextures(this);
                
                // Set world bounds for the current screen
                this.physics.world.setBounds(0, 0, 800, 400);
                
                // Create the main platform
                this.platforms = this.physics.add.staticGroup();
                this.platforms.create(400, 390, 'platform');
                
                // Create two small floating platforms
                this.platforms.create(200, 250, 'smallPlatform');
                this.platforms.create(600, 250, 'smallPlatform');
                
                // Create the player
                this.player = this.physics.add.sprite(100, 300, 'player');
                this.player.setBounce(0.2);
                this.player.setCollideWorldBounds(true);
                
                // Create enemies
                this.enemies = this.physics.add.group();
                this.createEnemies();
                
                // Create projectiles group
                this.projectiles = this.physics.add.group();
                
                // Set up collisions
                this.physics.add.collider(this.player, this.platforms);
                this.physics.add.collider(this.enemies, this.platforms);
                this.physics.add.collider(this.projectiles, this.platforms, (projectile) => {
                    projectile.destroy();
                });
                
                this.physics.add.overlap(this.projectiles, this.enemies, this.hitEnemy, null, this);
                this.physics.add.overlap(this.player, this.enemies, this.hitPlayer, null, this);
                
                // Controls
                this.cursors = this.input.keyboard.createCursorKeys();
                this.spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                
                // Add text for health and screen indicators
                this.healthText = this.add.text(16, 16, 'Health: 5', { fontSize: '24px', fill: '#fff' });
                this.screenText = this.add.text(650, 16, 'Screen: 1/5', { fontSize: '18px', fill: '#fff' });
                
                gameLog.success("Game scene created successfully");
            }
            
            createEnemies() {
                // Clear existing enemies
                this.enemies.clear(true, true);
                
                if (this.screen < this.totalScreens) {
                    // Regular screens have standard enemies
                    for (let i = 0; i < this.screen + 1; i++) {
                        const x = Phaser.Math.Between(200, 700);
                        const y = Phaser.Math.Between(50, 300);
                        
                        // Alternate between red and blue enemies
                        const enemyType = i % 2 === 0 ? 'redEnemy' : 'blueEnemy';
                        const enemy = this.enemies.create(x, y, enemyType);
                        
                        enemy.setBounce(1);
                        enemy.setCollideWorldBounds(true);
                        enemy.setVelocity(Phaser.Math.Between(-100, 100), Phaser.Math.Between(-50, 50));
                    }
                } else {
                    // Final screen has the boss
                    const boss = this.enemies.create(600, 200, 'boss');
                    boss.setBounce(1);
                    boss.setCollideWorldBounds(true);
                    boss.setVelocity(80, 60);
                    boss.health = 5;
                    boss.isBoss = true;
                }
            }
            
            update() {
                // Player movement
                if (this.cursors.left.isDown) {
                    this.player.setVelocityX(-160);
                } else if (this.cursors.right.isDown) {
                    this.player.setVelocityX(160);
                } else {
                    this.player.setVelocityX(0);
                }
                
                // Player jump
                if (this.cursors.up.isDown && this.player.body.touching.down) {
                    this.player.setVelocityY(-330);
                }
                
                // Player attack (shooting projectile)
                if (Phaser.Input.Keyboard.JustDown(this.spaceBar)) {
                    this.shootProjectile();
                }
                
                // Check if player has reached the right edge
                if (this.player.x > 780 && this.screen < this.totalScreens) {
                    this.nextScreen();
                }
            }
            
            shootProjectile() {
                const projectile = this.projectiles.create(this.player.x, this.player.y, 'projectile');
                projectile.setVelocityX(400);
                projectile.body.allowGravity = false;
                
                // Auto-destroy after 1 second
                this.time.delayedCall(1000, () => {
                    projectile.destroy();
                });
            }
            
            hitEnemy(projectile, enemy) {
                projectile.destroy();
                
                if (enemy.isBoss) {
                    enemy.health--;
                    
                    if (enemy.health <= 0) {
                        enemy.destroy();
                        this.add.text(400, 200, 'You Win!', { fontSize: '64px', fill: '#fff' }).setOrigin(0.5);
                        this.time.delayedCall(3000, () => {
                            this.scene.restart();
                            this.health = 5;
                            this.screen = 1;
                        });
                    }
                } else {
                    enemy.destroy();
                    this.enemiesKilled++;
                }
                
                // Check if all enemies are defeated
                if (this.enemies.countActive() === 0 && this.screen < this.totalScreens) {
                    // Prompt to move to next screen
                    this.add.text(400, 200, 'Proceed to next screen!', { fontSize: '24px', fill: '#fff' })
                        .setOrigin(0.5)
                        .setAlpha(0);
                }
            }
            
            hitPlayer(player, enemy) {
                // Make player temporarily invulnerable
                if (this.invulnerable) return;
                
                this.health--;
                this.healthText.setText('Health: ' + this.health);
                
                // Flash the player red
                this.player.setTint(0xff0000);
                
                // Make player briefly invulnerable
                this.invulnerable = true;
                
                this.time.delayedCall(1000, () => {
                    this.player.clearTint();
                    this.invulnerable = false;
                });
                
                if (this.health <= 0) {
                    this.add.text(400, 200, 'Game Over', { fontSize: '64px', fill: '#fff' }).setOrigin(0.5);
                    
                    this.time.delayedCall(3000, () => {
                        this.scene.restart();
                        this.health = 5;
                        this.screen = 1;
                    });
                }
            }
            
            nextScreen() {
                this.screen++;
                this.screenText.setText('Screen: ' + this.screen + '/' + this.totalScreens);
                
                // Reset player position
                this.player.x = 100;
                
                // Create new enemies for this screen
                this.createEnemies();
            }
        }
        
        // Try to initialize the game with different render types if needed
        function initGame(renderType) {
            try {
                gameLog.log(`Attempting to initialize game with renderer: ${renderType}`);
                
                const config = {
                    type: renderType,
                    width: 800,
                    height: 400,
                    parent: 'gameContainer',
                    backgroundColor: '#87CEEB',
                    physics: {
                        default: 'arcade',
                        arcade: {
                            gravity: { y: 300 },
                            debug: false
                        }
                    },
                    scene: MainScene,
                    render: {
                        pixelArt: false,
                        antialias: true,
                        antialiasGL: true
                    }
                };
                
                return new Phaser.Game(config);
            } catch (error) {
                gameLog.error(`Failed to initialize game with ${renderType}: ${error.message}`);
                return null;
            }
        }
        
        // First try with AUTO renderer (which will try WebGL first, then Canvas)
        let game = initGame(Phaser.AUTO);
        
        // If that fails, explicitly try CANVAS renderer
        if (!game) {
            gameLog.log("Falling back to canvas renderer...");
            game = initGame(Phaser.CANVAS);
        }
        
        // Update renderer info
        window.addEventListener('load', () => {
            try {
                if (game) {
                    const renderer = game.renderer.type === Phaser.WEBGL ? "WebGL" : "Canvas";
                    document.getElementById('rendererInfo').textContent = `Using ${renderer} Renderer`;
                    gameLog.success(`Game initialized successfully with ${renderer} renderer`);
                } else {
                    document.getElementById('rendererInfo').textContent = "Failed to initialize game";
                    gameLog.error("All renderer attempts failed");
                }
            } catch (e) {
                gameLog.error("Error detecting renderer: " + e.message);
            }
        });
    </script>
</body>
</html> 